---
title: Docker
author: seungbin
date: 2025-02-12 00:00
categories: [DEVOPS, Docker]
tags: [devops]
pin: true
math: true
mermaid: true
---
Docker란 리눅스 컨테이너 기반의 오픈소스 가상화 플랫폼

## **Docker Registry**
{: .mt-4 .mb-2}
도커 이미지를 저장하고 배포 할 수 있는 서버 프로그램을 말한다.<br/>
이미지를 저장하고 배포하는 표준 방법이다.

## **Docker Hub**
{: .mt-5 .mb-2}
도커 허브는 도커 사에서 호스팅하는 도커 레지스프리, 도커에서 기본적으로 참조한다.

## **Docker Image 구조**
{: .mt-5 .mb-2}
Docker 이미지는 여러 읽기 전용 레이어롤 구성된 스택 형태이다.<br/>
각 레이어는 Dockerfile의 명령어(RUN, COPY, ADD)를 실행할 때마다 새로 생성된다.<br/>
레이어는 이전 레이어를 기반으로 추가되며, 최종적으로 단일 이미지처럼 동작한다.

##### **Layer란 무엇인가?**
{: .mt-4 .mb-2}
도커에서 Layer는 이미지 파일 시스템을 구성하는 "변경분 단위"이다.

- Dockerfile의 주요 명령(`RUN`, `COPY`, `ADD`)이 실행될 때 새로운 레이어가 만들어진다.
- 각 레이어는 읽기 전용이며, 이전 레이어 위에 차곡차곡 쌓인다.
- 컨테이너 실행 시에는 맨 위에 쓰기 가능한 컨테이너 레이어가 하나 추가된다.

즉, 하나의 이미지가 하나의 파일이 아니라 여러 레이어 조합으로 동작하는 구조라고 이해하면 된다.

##### **Layer가 중요한 이유**
{: .mt-4 .mb-2}
- **빌드 캐시**: 변경되지 않은 레이어는 재사용되어 빌드 시간이 짧아진다.
- **전송 최적화**: 변경된 레이어만 push/pull 하므로 네트워크 비용이 줄어든다.
- **재사용성**: 동일한 베이스 레이어를 여러 이미지가 공유할 수 있다.

##### **레이어 설계 시 주의할 점**
{: .mt-4 .mb-2}
- 자주 바뀌는 파일(`source code`)은 Dockerfile의 뒤쪽에서 `COPY`하는 것이 캐시에 유리하다.
- 패키지 설치 같은 무거운 명령은 상대적으로 앞쪽에 두어 캐시 효율을 높인다.
- 불필요한 파일이 레이어에 포함되지 않도록 `.dockerignore`를 함께 관리한다.

##### **Image 이름 구조**
{: .mt-0 .mb-2}
도커의 일반적인 이미지 이름 구조는 아래와 같다
```
[registry/namespace/]repository[:tag]
```
{: .mt-0 .mb-0}
- registry (optional)
  - 이미지를 저장하는 docker 레지스트리의 주소를 나타낸다.
  - 생략가능하며 생략하면 기본적으로 docker hub(docker.io)를 사용한다.
- namespace (optional)
  - 저장소를 논리적으로 그룹화하여 다른 팀 또는 프로젝트 간의 충돌을 방지하기 위함이며 특정 사용자의 이름이나 조직이름을 나타낸다.
- repository (mandatory)
  - namespace의 다음에 위치하며 이미지의 이름을 나타낸다.
  - 실제 docker 이미지의 이름으로 특정 애플리케이션이나 서비스와 연결된다.
- tag (optional)
  - 이미지의 버전이나 변형을 나타낸다.
  - 특정 버전의 이미지를 지정하거나 관리할 수 있다.
  - 생략 가능하며 태그를 생략하면 기본적으로 :latest 태그가 사용된다.

##### **- Image Push/Pull**
{: .mt-0 .mb-2}
이미지를 Push/Pull 할 때 기본적으로 도커 허브가 기본 레지스트리이기 때문에 이미지 이름의 registry 부분에 docker.io가 <br/>생략되어 있으며 명령어 ’docker pull ubuntu’ 는 ‘docker pull docker.io/library/ubuntu’를 의미한다.<br/>
따라서 특정 레지스트리에 대해 이미지를 Push/Pull 하기 위해서는 이미지 이름의 registry 부분에 특정 레지스트리의 주소 정보를 작성해야한다.

## **DockerFile**
{: .mt-5 .mb-2}
Docker Image를 생성하기 위한 스크립트이다.<br/>
Docker 프로그램이 DockerFile에 나열된 명령문을 차례로 수행하여 docker image를 생성한다.<br/>
파일의 이름은 DockerFile로 지정해야한다.

##### **- 명령어**
{: .mt-0 .mb-2}
- FROM : 베이스 이미지, 어느 이미지에서 시작할 것인지를 의미
- MAINTAINER : 이미지를 생성한 개발자의 정보(1.13.0 이후 사용하지 않는다.)
- LABEL : 이미지에 메타데이터를 추가 한다.(Key - value 형태)
- RUN : 새로운 레이어에서 명령어를 실행하고, 새로운 이미지를 생성한다.
  - run 명령을 실행할 때마다 새로운 레이어가 생성되고 해당 명령어의 결과를 새로운 레이에어 저장한다.
  - 레이어의 수를 최소화하고 빌드 속도를 높이기 위해 여러 명령어를 하나의 RUN으로 합쳐 작성하는것이 효율적이다.
- WORKDIR : 작업 디렉토리를 지정, 해당 디렉토리가 없으면 새로 생성한다.
- COPY / ADD : build 명령 중간에 호스트의 파일 또는 폴더를 이미지에 가져오는것
- ADD 명령문은 좀 더 파워풀한 COPY 명령문이라고 생각할 수 있다.

## **WORKDIR는 도대체 무슨 의미일까?**
{: .mt-5 .mb-2}
Dockerfile을 작성하다 보면 아래 같은 설명을 자주 보게 된다.

- 컨테이너 내부 작업 디렉토리 설정
- 이후 명령은 `/app` 경로 기준으로 실행됨

처음 보면 "이미지를 빌드하는데 왜 컨테이너 내부 폴더 구조를 말하지?"라는 의문이 생긴다.

##### **1. Docker Image와 Container의 관계**
{: .mt-4 .mb-2}
Docker를 이해하려면 아래 흐름을 먼저 잡아야 한다.

```text
Dockerfile -> Image -> Container
```

- Docker Image
  - 실행 환경이 담긴 설계도
  - 파일 시스템 스냅샷
  - 아직 실행되지 않은 상태
- Docker Container
  - Image를 실행한 실제 프로세스
  - 살아있는 실행 환경
  - 내부에 리눅스 파일 시스템이 존재

즉, Dockerfile은 단순 스크립트가 아니라 컨테이너가 실행될 리눅스 환경을 미리 정의하는 설계도다.

##### **2. Docker Image는 압축된 리눅스 파일 시스템이다**
{: .mt-4 .mb-2}
Docker Image는 단순한 JAR 묶음이 아니다. 이미지 안에는 컨테이너가 사용할 파일 시스템 구조가 포함된다.

```text
/
|-- app
|-- usr
|-- etc
|-- lib
`-- ...
```

그래서 Dockerfile에서 경로를 설정하는 명령이 중요한 것이다.

##### **3. WORKDIR의 정확한 의미**
{: .mt-4 .mb-2}

```dockerfile
WORKDIR /app
```

의미:
- 컨테이너 내부에서 앞으로 작업할 기본 디렉토리를 `/app`으로 설정한다.
- 리눅스에서 `cd /app` 한 것과 유사한 기준점 역할을 한다.

##### **4. 이후 명령이 /app 기준으로 실행된다는 뜻**
{: .mt-4 .mb-2}

```dockerfile
WORKDIR /app
COPY build/libs/*.jar app.jar
```

동작 결과:

```text
(호스트) build/libs/myapp.jar
        ->
(컨테이너 내부) /app/app.jar
```

`WORKDIR`가 없다면 아래처럼 루트(`/`) 기준으로 동작한다.

```dockerfile
COPY build/libs/*.jar app.jar
```

```text
/app.jar
```

##### **5. 빌드 단계에서 왜 컨테이너 내부 경로를 다루는가**
{: .mt-4 .mb-2}
핵심은 아래 한 줄로 정리된다.

- Docker 이미지는 결국 "컨테이너가 실행될 파일 시스템을 미리 만들어놓은 것"

따라서:
- `WORKDIR`는 이미지 내부 파일 구조의 기준 경로를 정하는 명령
- `COPY`는 그 구조 안에 파일을 배치하는 명령

##### **6. Docker Image와 Kubernetes Pod의 관계**
{: .mt-4 .mb-2}

```text
Dockerfile
   ->
Docker Image
   ->
Container
   ->
Pod (Kubernetes가 감싸서 관리)
```

Kubernetes는 컨테이너를 직접 관리하지 않고 Pod 단위로 관리한다.

##### **7. 정리**
{: .mt-4 .mb-2}
- `WORKDIR`는 컨테이너 내부 기준 디렉토리를 설정하는 명령이다.
- Docker Image는 실행될 리눅스 파일 시스템을 미리 구성한 결과물이다.
- Container는 실행된 Image다.
- Kubernetes는 Container를 Pod 단위로 운영한다.
